// This code was autogenerated with `dbus-codegen-rust --crossroads -s -d org.freedesktop.NetworkManager -p /org/freedesktop/NetworkManager`, see https://github.com/diwic/dbus-rs
#![allow(dead_code)]
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_crossroads as crossroads;

pub trait OrgFreedesktopDBusProperties {
    fn get(&mut self, interface_name: String, property_name: String) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::MethodErr>;
    fn get_all(&mut self, interface_name: String) -> Result<arg::PropMap, dbus::MethodErr>;
    fn set(&mut self, interface_name: String, property_name: String, value: arg::Variant<Box<dyn arg::RefArg + 'static>>) -> Result<(), dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface_name: String,
    pub changed_properties: arg::PropMap,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface_name, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface_name: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

pub fn register_org_freedesktop_dbus_properties<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusProperties + Send + 'static
{
    cr.register("org.freedesktop.DBus.Properties", |b| {
        b.signal::<(String,arg::PropMap,Vec<String>,), _>("PropertiesChanged", ("interface_name","changed_properties","invalidated_properties",));
        b.method("Get", ("interface_name","property_name",), ("value",), |_, t: &mut T, (interface_name,property_name,)| {
            t.get(interface_name,property_name,)
                .map(|x| (x,))
        });
        b.method("GetAll", ("interface_name",), ("properties",), |_, t: &mut T, (interface_name,)| {
            t.get_all(interface_name,)
                .map(|x| (x,))
        });
        b.method("Set", ("interface_name","property_name","value",), (), |_, t: &mut T, (interface_name,property_name,value,)| {
            t.set(interface_name,property_name,value,)
        });
    })
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&mut self) -> Result<String, dbus::MethodErr>;
}

pub fn register_org_freedesktop_dbus_introspectable<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusIntrospectable + Send + 'static
{
    cr.register("org.freedesktop.DBus.Introspectable", |b| {
        b.method("Introspect", (), ("xml_data",), |_, t: &mut T, ()| {
            t.introspect()
                .map(|x| (x,))
        });
    })
}

pub trait OrgFreedesktopDBusPeer {
    fn ping(&mut self) -> Result<(), dbus::MethodErr>;
    fn get_machine_id(&mut self) -> Result<String, dbus::MethodErr>;
}

pub fn register_org_freedesktop_dbus_peer<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusPeer + Send + 'static
{
    cr.register("org.freedesktop.DBus.Peer", |b| {
        b.method("Ping", (), (), |_, t: &mut T, ()| {
            t.ping()
        });
        b.method("GetMachineId", (), ("machine_uuid",), |_, t: &mut T, ()| {
            t.get_machine_id()
                .map(|x| (x,))
        });
    })
}

pub trait OrgFreedesktopNetworkManager {
    fn reload(&mut self, flags: u32) -> Result<(), dbus::MethodErr>;
    fn get_devices(&mut self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
    fn get_all_devices(&mut self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
    fn get_device_by_ip_iface(&mut self, iface: String) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn activate_connection(&mut self, connection: dbus::Path<'static>, device: dbus::Path<'static>, specific_object: dbus::Path<'static>) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn add_and_activate_connection(&mut self, connection: ::std::collections::HashMap<String, arg::PropMap>, device: dbus::Path<'static>, specific_object: dbus::Path<'static>) -> Result<(dbus::Path<'static>, dbus::Path<'static>), dbus::MethodErr>;
    fn add_and_activate_connection2(&mut self, connection: ::std::collections::HashMap<String, arg::PropMap>, device: dbus::Path<'static>, specific_object: dbus::Path<'static>, options: arg::PropMap) -> Result<(dbus::Path<'static>, dbus::Path<'static>, arg::PropMap), dbus::MethodErr>;
    fn deactivate_connection(&mut self, active_connection: dbus::Path<'static>) -> Result<(), dbus::MethodErr>;
    fn sleep(&mut self, sleep: bool) -> Result<(), dbus::MethodErr>;
    fn enable(&mut self, enable: bool) -> Result<(), dbus::MethodErr>;
    fn get_permissions(&mut self) -> Result<::std::collections::HashMap<String, String>, dbus::MethodErr>;
    fn set_logging(&mut self, level: String, domains: String) -> Result<(), dbus::MethodErr>;
    fn get_logging(&mut self) -> Result<(String, String), dbus::MethodErr>;
    fn check_connectivity(&mut self) -> Result<u32, dbus::MethodErr>;
    fn state(&mut self) -> Result<u32, dbus::MethodErr>;
    fn checkpoint_create(&mut self, devices: Vec<dbus::Path<'static>>, rollback_timeout: u32, flags: u32) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn checkpoint_destroy(&mut self, checkpoint: dbus::Path<'static>) -> Result<(), dbus::MethodErr>;
    fn checkpoint_rollback(&mut self, checkpoint: dbus::Path<'static>) -> Result<::std::collections::HashMap<String, u32>, dbus::MethodErr>;
    fn checkpoint_adjust_rollback_timeout(&mut self, checkpoint: dbus::Path<'static>, add_timeout: u32) -> Result<(), dbus::MethodErr>;
    fn devices(&self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
    fn all_devices(&self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
    fn checkpoints(&self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
    fn networking_enabled(&self) -> Result<bool, dbus::MethodErr>;
    fn wireless_enabled(&self) -> Result<bool, dbus::MethodErr>;
    fn set_wireless_enabled(&self, value: bool) -> Result<(), dbus::MethodErr>;
    fn wireless_hardware_enabled(&self) -> Result<bool, dbus::MethodErr>;
    fn wwan_enabled(&self) -> Result<bool, dbus::MethodErr>;
    fn set_wwan_enabled(&self, value: bool) -> Result<(), dbus::MethodErr>;
    fn wwan_hardware_enabled(&self) -> Result<bool, dbus::MethodErr>;
    #[deprecated(note = "true")]
    fn wimax_enabled(&self) -> Result<bool, dbus::MethodErr>;
    #[deprecated(note = "true")]
    fn set_wimax_enabled(&self, value: bool) -> Result<(), dbus::MethodErr>;
    #[deprecated(note = "true")]
    fn wimax_hardware_enabled(&self) -> Result<bool, dbus::MethodErr>;
    fn radio_flags(&self) -> Result<u32, dbus::MethodErr>;
    fn active_connections(&self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
    fn primary_connection(&self) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn primary_connection_type(&self) -> Result<String, dbus::MethodErr>;
    fn metered(&self) -> Result<u32, dbus::MethodErr>;
    fn activating_connection(&self) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn startup(&self) -> Result<bool, dbus::MethodErr>;
    fn version(&self) -> Result<String, dbus::MethodErr>;
    fn version_info(&self) -> Result<Vec<u32>, dbus::MethodErr>;
    fn capabilities(&self) -> Result<Vec<u32>, dbus::MethodErr>;
    fn state_(&self) -> Result<u32, dbus::MethodErr>;
    fn connectivity(&self) -> Result<u32, dbus::MethodErr>;
    fn connectivity_check_available(&self) -> Result<bool, dbus::MethodErr>;
    fn connectivity_check_enabled(&self) -> Result<bool, dbus::MethodErr>;
    fn set_connectivity_check_enabled(&self, value: bool) -> Result<(), dbus::MethodErr>;
    fn connectivity_check_uri(&self) -> Result<String, dbus::MethodErr>;
    fn global_dns_configuration(&self) -> Result<arg::PropMap, dbus::MethodErr>;
    fn set_global_dns_configuration(&self, value: arg::PropMap) -> Result<(), dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerCheckPermissions {
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerCheckPermissions {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerCheckPermissions {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerCheckPermissions {
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerCheckPermissions {
    const NAME: &'static str = "CheckPermissions";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager";
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerStateChanged {
    pub state: u32,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerStateChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.state, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerStateChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerStateChanged {
            state: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerStateChanged {
    const NAME: &'static str = "StateChanged";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager";
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerDeviceAdded {
    pub device_path: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerDeviceAdded {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.device_path, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerDeviceAdded {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerDeviceAdded {
            device_path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerDeviceAdded {
    const NAME: &'static str = "DeviceAdded";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager";
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerDeviceRemoved {
    pub device_path: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerDeviceRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.device_path, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerDeviceRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerDeviceRemoved {
            device_path: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerDeviceRemoved {
    const NAME: &'static str = "DeviceRemoved";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager";
}

pub fn register_org_freedesktop_network_manager<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopNetworkManager + Send + 'static
{
    cr.register("org.freedesktop.NetworkManager", |b| {
        b.signal::<(), _>("CheckPermissions", ());
        b.signal::<(u32,), _>("StateChanged", ("state",));
        b.signal::<(dbus::Path<'static>,), _>("DeviceAdded", ("device_path",));
        b.signal::<(dbus::Path<'static>,), _>("DeviceRemoved", ("device_path",));
        b.method("Reload", ("flags",), (), |_, t: &mut T, (flags,)| {
            t.reload(flags,)
        });
        b.method("GetDevices", (), ("devices",), |_, t: &mut T, ()| {
            t.get_devices()
                .map(|x| (x,))
        });
        b.method("GetAllDevices", (), ("devices",), |_, t: &mut T, ()| {
            t.get_all_devices()
                .map(|x| (x,))
        });
        b.method("GetDeviceByIpIface", ("iface",), ("device",), |_, t: &mut T, (iface,)| {
            t.get_device_by_ip_iface(iface,)
                .map(|x| (x,))
        });
        b.method("ActivateConnection", ("connection","device","specific_object",), ("active_connection",), |_, t: &mut T, (connection,device,specific_object,)| {
            t.activate_connection(connection,device,specific_object,)
                .map(|x| (x,))
        });
        b.method("AddAndActivateConnection", ("connection","device","specific_object",), ("path","active_connection",), |_, t: &mut T, (connection,device,specific_object,)| {
            t.add_and_activate_connection(connection,device,specific_object,)
        });
        b.method("AddAndActivateConnection2", ("connection","device","specific_object","options",), ("path","active_connection","result",), |_, t: &mut T, (connection,device,specific_object,options,)| {
            t.add_and_activate_connection2(connection,device,specific_object,options,)
        });
        b.method("DeactivateConnection", ("active_connection",), (), |_, t: &mut T, (active_connection,)| {
            t.deactivate_connection(active_connection,)
        });
        b.method("Sleep", ("sleep",), (), |_, t: &mut T, (sleep,)| {
            t.sleep(sleep,)
        });
        b.method("Enable", ("enable",), (), |_, t: &mut T, (enable,)| {
            t.enable(enable,)
        });
        b.method("GetPermissions", (), ("permissions",), |_, t: &mut T, ()| {
            t.get_permissions()
                .map(|x| (x,))
        });
        b.method("SetLogging", ("level","domains",), (), |_, t: &mut T, (level,domains,)| {
            t.set_logging(level,domains,)
        });
        b.method("GetLogging", (), ("level","domains",), |_, t: &mut T, ()| {
            t.get_logging()
        });
        b.method("CheckConnectivity", (), ("connectivity",), |_, t: &mut T, ()| {
            t.check_connectivity()
                .map(|x| (x,))
        });
        b.method("state", (), ("state",), |_, t: &mut T, ()| {
            t.state()
                .map(|x| (x,))
        });
        b.method("CheckpointCreate", ("devices","rollback_timeout","flags",), ("checkpoint",), |_, t: &mut T, (devices,rollback_timeout,flags,)| {
            t.checkpoint_create(devices,rollback_timeout,flags,)
                .map(|x| (x,))
        });
        b.method("CheckpointDestroy", ("checkpoint",), (), |_, t: &mut T, (checkpoint,)| {
            t.checkpoint_destroy(checkpoint,)
        });
        b.method("CheckpointRollback", ("checkpoint",), ("result",), |_, t: &mut T, (checkpoint,)| {
            t.checkpoint_rollback(checkpoint,)
                .map(|x| (x,))
        });
        b.method("CheckpointAdjustRollbackTimeout", ("checkpoint","add_timeout",), (), |_, t: &mut T, (checkpoint,add_timeout,)| {
            t.checkpoint_adjust_rollback_timeout(checkpoint,add_timeout,)
        });
        b.property::<Vec<dbus::Path<'static>>, _>("Devices")
            .get(|_, t: &mut T| t.devices());
        b.property::<Vec<dbus::Path<'static>>, _>("AllDevices")
            .get(|_, t: &mut T| t.all_devices());
        b.property::<Vec<dbus::Path<'static>>, _>("Checkpoints")
            .get(|_, t: &mut T| t.checkpoints());
        b.property::<bool, _>("NetworkingEnabled")
            .get(|_, t: &mut T| t.networking_enabled());
        b.property::<bool, _>("WirelessEnabled")
            .get(|_, t: &mut T| t.wireless_enabled())
            .set(|_, t: &mut T, value| t.set_wireless_enabled(value).map(|_| None));
        b.property::<bool, _>("WirelessHardwareEnabled")
            .get(|_, t: &mut T| t.wireless_hardware_enabled());
        b.property::<bool, _>("WwanEnabled")
            .get(|_, t: &mut T| t.wwan_enabled())
            .set(|_, t: &mut T, value| t.set_wwan_enabled(value).map(|_| None));
        b.property::<bool, _>("WwanHardwareEnabled")
            .get(|_, t: &mut T| t.wwan_hardware_enabled());
        b.property::<bool, _>("WimaxEnabled")
            .get(|_, t: &mut T| t.wimax_enabled())
            .set(|_, t: &mut T, value| t.set_wimax_enabled(value).map(|_| None))
            .annotate("org.freedesktop.DBus.Deprecated", "true");
        b.property::<bool, _>("WimaxHardwareEnabled")
            .get(|_, t: &mut T| t.wimax_hardware_enabled())
            .annotate("org.freedesktop.DBus.Deprecated", "true");
        b.property::<u32, _>("RadioFlags")
            .get(|_, t: &mut T| t.radio_flags());
        b.property::<Vec<dbus::Path<'static>>, _>("ActiveConnections")
            .get(|_, t: &mut T| t.active_connections());
        b.property::<dbus::Path<'static>, _>("PrimaryConnection")
            .get(|_, t: &mut T| t.primary_connection());
        b.property::<String, _>("PrimaryConnectionType")
            .get(|_, t: &mut T| t.primary_connection_type());
        b.property::<u32, _>("Metered")
            .get(|_, t: &mut T| t.metered());
        b.property::<dbus::Path<'static>, _>("ActivatingConnection")
            .get(|_, t: &mut T| t.activating_connection());
        b.property::<bool, _>("Startup")
            .get(|_, t: &mut T| t.startup());
        b.property::<String, _>("Version")
            .get(|_, t: &mut T| t.version());
        b.property::<Vec<u32>, _>("VersionInfo")
            .get(|_, t: &mut T| t.version_info());
        b.property::<Vec<u32>, _>("Capabilities")
            .get(|_, t: &mut T| t.capabilities());
        b.property::<u32, _>("State")
            .get(|_, t: &mut T| t.state_());
        b.property::<u32, _>("Connectivity")
            .get(|_, t: &mut T| t.connectivity());
        b.property::<bool, _>("ConnectivityCheckAvailable")
            .get(|_, t: &mut T| t.connectivity_check_available());
        b.property::<bool, _>("ConnectivityCheckEnabled")
            .get(|_, t: &mut T| t.connectivity_check_enabled())
            .set(|_, t: &mut T, value| t.set_connectivity_check_enabled(value).map(|_| None));
        b.property::<String, _>("ConnectivityCheckUri")
            .get(|_, t: &mut T| t.connectivity_check_uri());
        b.property::<arg::PropMap, _>("GlobalDnsConfiguration")
            .get(|_, t: &mut T| t.global_dns_configuration())
            .set(|_, t: &mut T, value| t.set_global_dns_configuration(value).map(|_| None));
    })
}
