// This code was autogenerated with multiple introspections of two different types of NetworkManager devices and stitched together manually:
// A wired device was introspected with `dbus-codegen-rust --crossroads -s -d org.freedesktop.NetworkManager -p /org/freedesktop/NetworkManager/Devices/3`
// A wireless device was introspected with `dbus-codegen-rust --crossroads -s -d org.freedesktop.NetworkManager -p /org/freedesktop/NetworkManager/Devices/4`
// see https://github.com/diwic/dbus-rs
#![allow(dead_code)]
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_crossroads as crossroads;

pub trait OrgFreedesktopDBusProperties {
    fn get(&mut self, interface_name: String, property_name: String) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::MethodErr>;
    fn get_all(&mut self, interface_name: String) -> Result<arg::PropMap, dbus::MethodErr>;
    fn set(&mut self, interface_name: String, property_name: String, value: arg::Variant<Box<dyn arg::RefArg + 'static>>) -> Result<(), dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface_name: String,
    pub changed_properties: arg::PropMap,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface_name, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface_name: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

pub fn register_org_freedesktop_dbus_properties<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusProperties + Send + 'static
{
    cr.register("org.freedesktop.DBus.Properties", |b| {
        b.signal::<(String,arg::PropMap,Vec<String>,), _>("PropertiesChanged", ("interface_name","changed_properties","invalidated_properties",));
        b.method("Get", ("interface_name","property_name",), ("value",), |_, t: &mut T, (interface_name,property_name,)| {
            t.get(interface_name,property_name,)
                .map(|x| (x,))
        });
        b.method("GetAll", ("interface_name",), ("properties",), |_, t: &mut T, (interface_name,)| {
            t.get_all(interface_name,)
                .map(|x| (x,))
        });
        b.method("Set", ("interface_name","property_name","value",), (), |_, t: &mut T, (interface_name,property_name,value,)| {
            t.set(interface_name,property_name,value,)
        });
    })
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&mut self) -> Result<String, dbus::MethodErr>;
}

pub fn register_org_freedesktop_dbus_introspectable<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusIntrospectable + Send + 'static
{
    cr.register("org.freedesktop.DBus.Introspectable", |b| {
        b.method("Introspect", (), ("xml_data",), |_, t: &mut T, ()| {
            t.introspect()
                .map(|x| (x,))
        });
    })
}

pub trait OrgFreedesktopDBusPeer {
    fn ping(&mut self) -> Result<(), dbus::MethodErr>;
    fn get_machine_id(&mut self) -> Result<String, dbus::MethodErr>;
}

pub fn register_org_freedesktop_dbus_peer<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusPeer + Send + 'static
{
    cr.register("org.freedesktop.DBus.Peer", |b| {
        b.method("Ping", (), (), |_, t: &mut T, ()| {
            t.ping()
        });
        b.method("GetMachineId", (), ("machine_uuid",), |_, t: &mut T, ()| {
            t.get_machine_id()
                .map(|x| (x,))
        });
    })
}

pub trait OrgFreedesktopNetworkManagerDeviceStatistics {
    fn refresh_rate_ms(&self) -> Result<u32, dbus::MethodErr>;
    fn set_refresh_rate_ms(&self, value: u32) -> Result<(), dbus::MethodErr>;
    fn tx_bytes(&self) -> Result<u64, dbus::MethodErr>;
    fn rx_bytes(&self) -> Result<u64, dbus::MethodErr>;
}

pub fn register_org_freedesktop_network_manager_device_statistics<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopNetworkManagerDeviceStatistics + Send + 'static
{
    cr.register("org.freedesktop.NetworkManager.Device.Statistics", |b| {
        b.property::<u32, _>("RefreshRateMs")
            .get(|_, t: &mut T| t.refresh_rate_ms())
            .set(|_, t: &mut T, value| t.set_refresh_rate_ms(value).map(|_| None));
        b.property::<u64, _>("TxBytes")
            .get(|_, t: &mut T| t.tx_bytes());
        b.property::<u64, _>("RxBytes")
            .get(|_, t: &mut T| t.rx_bytes());
    })
}

pub trait OrgFreedesktopNetworkManagerDeviceWireless {
    #[deprecated(note = "true")]
    fn get_access_points(&mut self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
    fn get_all_access_points(&mut self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
    fn request_scan(&mut self, options: arg::PropMap) -> Result<(), dbus::MethodErr>;
    fn hw_address(&self) -> Result<String, dbus::MethodErr>;
    #[deprecated(note = "true")]
    fn perm_hw_address(&self) -> Result<String, dbus::MethodErr>;
    fn mode(&self) -> Result<u32, dbus::MethodErr>;
    fn bitrate(&self) -> Result<u32, dbus::MethodErr>;
    fn access_points(&self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
    fn active_access_point(&self) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn wireless_capabilities(&self) -> Result<u32, dbus::MethodErr>;
    fn last_scan(&self) -> Result<i64, dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerDeviceWirelessAccessPointAdded {
    pub access_point: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerDeviceWirelessAccessPointAdded {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.access_point, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerDeviceWirelessAccessPointAdded {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerDeviceWirelessAccessPointAdded {
            access_point: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerDeviceWirelessAccessPointAdded {
    const NAME: &'static str = "AccessPointAdded";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager.Device.Wireless";
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerDeviceWirelessAccessPointRemoved {
    pub access_point: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerDeviceWirelessAccessPointRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.access_point, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerDeviceWirelessAccessPointRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerDeviceWirelessAccessPointRemoved {
            access_point: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerDeviceWirelessAccessPointRemoved {
    const NAME: &'static str = "AccessPointRemoved";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager.Device.Wireless";
}

pub fn register_org_freedesktop_network_manager_device_wireless<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopNetworkManagerDeviceWireless + Send + 'static
{
    cr.register("org.freedesktop.NetworkManager.Device.Wireless", |b| {
        b.signal::<(dbus::Path<'static>,), _>("AccessPointAdded", ("access_point",));
        b.signal::<(dbus::Path<'static>,), _>("AccessPointRemoved", ("access_point",));
        b.method("GetAccessPoints", (), ("access_points",), |_, t: &mut T, ()| {
            t.get_access_points()
                .map(|x| (x,))
        })
            .annotate("org.freedesktop.DBus.Deprecated", "true");
        b.method("GetAllAccessPoints", (), ("access_points",), |_, t: &mut T, ()| {
            t.get_all_access_points()
                .map(|x| (x,))
        });
        b.method("RequestScan", ("options",), (), |_, t: &mut T, (options,)| {
            t.request_scan(options,)
        });
        b.property::<String, _>("HwAddress")
            .get(|_, t: &mut T| t.hw_address());
        b.property::<String, _>("PermHwAddress")
            .get(|_, t: &mut T| t.perm_hw_address())
            .annotate("org.freedesktop.DBus.Deprecated", "true");
        b.property::<u32, _>("Mode")
            .get(|_, t: &mut T| t.mode());
        b.property::<u32, _>("Bitrate")
            .get(|_, t: &mut T| t.bitrate());
        b.property::<Vec<dbus::Path<'static>>, _>("AccessPoints")
            .get(|_, t: &mut T| t.access_points());
        b.property::<dbus::Path<'static>, _>("ActiveAccessPoint")
            .get(|_, t: &mut T| t.active_access_point());
        b.property::<u32, _>("WirelessCapabilities")
            .get(|_, t: &mut T| t.wireless_capabilities());
        b.property::<i64, _>("LastScan")
            .get(|_, t: &mut T| t.last_scan());
    })
}

pub trait OrgFreedesktopNetworkManagerDevice {
    fn reapply(&mut self, connection: ::std::collections::HashMap<String, arg::PropMap>, version_id: u64, flags: u32) -> Result<(), dbus::MethodErr>;
    fn get_applied_connection(&mut self, flags: u32) -> Result<(::std::collections::HashMap<String, arg::PropMap>, u64), dbus::MethodErr>;
    fn disconnect(&mut self) -> Result<(), dbus::MethodErr>;
    fn delete(&mut self) -> Result<(), dbus::MethodErr>;
    fn udi(&self) -> Result<String, dbus::MethodErr>;
    fn path(&self) -> Result<String, dbus::MethodErr>;
    fn interface(&self) -> Result<String, dbus::MethodErr>;
    fn ip_interface(&self) -> Result<String, dbus::MethodErr>;
    fn driver(&self) -> Result<String, dbus::MethodErr>;
    fn driver_version(&self) -> Result<String, dbus::MethodErr>;
    fn firmware_version(&self) -> Result<String, dbus::MethodErr>;
    fn capabilities(&self) -> Result<u32, dbus::MethodErr>;
    #[deprecated(note = "true")]
    fn ip4_address(&self) -> Result<u32, dbus::MethodErr>;
    fn state(&self) -> Result<u32, dbus::MethodErr>;
    fn state_reason(&self) -> Result<(u32, u32,), dbus::MethodErr>;
    fn active_connection(&self) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn ip4_config(&self) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn dhcp4_config(&self) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn ip6_config(&self) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn dhcp6_config(&self) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn managed(&self) -> Result<bool, dbus::MethodErr>;
    fn set_managed(&self, value: bool) -> Result<(), dbus::MethodErr>;
    fn autoconnect(&self) -> Result<bool, dbus::MethodErr>;
    fn set_autoconnect(&self, value: bool) -> Result<(), dbus::MethodErr>;
    fn firmware_missing(&self) -> Result<bool, dbus::MethodErr>;
    fn nm_plugin_missing(&self) -> Result<bool, dbus::MethodErr>;
    fn device_type(&self) -> Result<u32, dbus::MethodErr>;
    fn available_connections(&self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
    fn physical_port_id(&self) -> Result<String, dbus::MethodErr>;
    fn mtu(&self) -> Result<u32, dbus::MethodErr>;
    fn metered(&self) -> Result<u32, dbus::MethodErr>;
    fn lldp_neighbors(&self) -> Result<Vec<arg::PropMap>, dbus::MethodErr>;
    fn real(&self) -> Result<bool, dbus::MethodErr>;
    fn ip4_connectivity(&self) -> Result<u32, dbus::MethodErr>;
    fn ip6_connectivity(&self) -> Result<u32, dbus::MethodErr>;
    fn interface_flags(&self) -> Result<u32, dbus::MethodErr>;
    fn hw_address(&self) -> Result<String, dbus::MethodErr>;
    fn ports(&self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgFreedesktopNetworkManagerDeviceStateChanged {
    pub new_state: u32,
    pub old_state: u32,
    pub reason: u32,
}

impl arg::AppendAll for OrgFreedesktopNetworkManagerDeviceStateChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.new_state, i);
        arg::RefArg::append(&self.old_state, i);
        arg::RefArg::append(&self.reason, i);
    }
}

impl arg::ReadAll for OrgFreedesktopNetworkManagerDeviceStateChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopNetworkManagerDeviceStateChanged {
            new_state: i.read()?,
            old_state: i.read()?,
            reason: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopNetworkManagerDeviceStateChanged {
    const NAME: &'static str = "StateChanged";
    const INTERFACE: &'static str = "org.freedesktop.NetworkManager.Device";
}

pub fn register_org_freedesktop_network_manager_device<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopNetworkManagerDevice + Send + 'static
{
    cr.register("org.freedesktop.NetworkManager.Device", |b| {
        b.signal::<(u32,u32,u32,), _>("StateChanged", ("new_state","old_state","reason",));
        b.method("Reapply", ("connection","version_id","flags",), (), |_, t: &mut T, (connection,version_id,flags,)| {
            t.reapply(connection,version_id,flags,)
        });
        b.method("GetAppliedConnection", ("flags",), ("connection","version_id",), |_, t: &mut T, (flags,)| {
            t.get_applied_connection(flags,)
        });
        b.method("Disconnect", (), (), |_, t: &mut T, ()| {
            t.disconnect()
        });
        b.method("Delete", (), (), |_, t: &mut T, ()| {
            t.delete()
        });
        b.property::<String, _>("Udi")
            .get(|_, t: &mut T| t.udi());
        b.property::<String, _>("Path")
            .get(|_, t: &mut T| t.path());
        b.property::<String, _>("Interface")
            .get(|_, t: &mut T| t.interface());
        b.property::<String, _>("IpInterface")
            .get(|_, t: &mut T| t.ip_interface());
        b.property::<String, _>("Driver")
            .get(|_, t: &mut T| t.driver());
        b.property::<String, _>("DriverVersion")
            .get(|_, t: &mut T| t.driver_version());
        b.property::<String, _>("FirmwareVersion")
            .get(|_, t: &mut T| t.firmware_version());
        b.property::<u32, _>("Capabilities")
            .get(|_, t: &mut T| t.capabilities());
        b.property::<u32, _>("Ip4Address")
            .get(|_, t: &mut T| t.ip4_address())
            .annotate("org.freedesktop.DBus.Deprecated", "true");
        b.property::<u32, _>("State")
            .get(|_, t: &mut T| t.state());
        b.property::<(u32, u32,), _>("StateReason")
            .get(|_, t: &mut T| t.state_reason());
        b.property::<dbus::Path<'static>, _>("ActiveConnection")
            .get(|_, t: &mut T| t.active_connection());
        b.property::<dbus::Path<'static>, _>("Ip4Config")
            .get(|_, t: &mut T| t.ip4_config());
        b.property::<dbus::Path<'static>, _>("Dhcp4Config")
            .get(|_, t: &mut T| t.dhcp4_config());
        b.property::<dbus::Path<'static>, _>("Ip6Config")
            .get(|_, t: &mut T| t.ip6_config());
        b.property::<dbus::Path<'static>, _>("Dhcp6Config")
            .get(|_, t: &mut T| t.dhcp6_config());
        b.property::<bool, _>("Managed")
            .get(|_, t: &mut T| t.managed())
            .set(|_, t: &mut T, value| t.set_managed(value).map(|_| None));
        b.property::<bool, _>("Autoconnect")
            .get(|_, t: &mut T| t.autoconnect())
            .set(|_, t: &mut T, value| t.set_autoconnect(value).map(|_| None));
        b.property::<bool, _>("FirmwareMissing")
            .get(|_, t: &mut T| t.firmware_missing());
        b.property::<bool, _>("NmPluginMissing")
            .get(|_, t: &mut T| t.nm_plugin_missing());
        b.property::<u32, _>("DeviceType")
            .get(|_, t: &mut T| t.device_type());
        b.property::<Vec<dbus::Path<'static>>, _>("AvailableConnections")
            .get(|_, t: &mut T| t.available_connections());
        b.property::<String, _>("PhysicalPortId")
            .get(|_, t: &mut T| t.physical_port_id());
        b.property::<u32, _>("Mtu")
            .get(|_, t: &mut T| t.mtu());
        b.property::<u32, _>("Metered")
            .get(|_, t: &mut T| t.metered());
        b.property::<Vec<arg::PropMap>, _>("LldpNeighbors")
            .get(|_, t: &mut T| t.lldp_neighbors());
        b.property::<bool, _>("Real")
            .get(|_, t: &mut T| t.real());
        b.property::<u32, _>("Ip4Connectivity")
            .get(|_, t: &mut T| t.ip4_connectivity());
        b.property::<u32, _>("Ip6Connectivity")
            .get(|_, t: &mut T| t.ip6_connectivity());
        b.property::<u32, _>("InterfaceFlags")
            .get(|_, t: &mut T| t.interface_flags());
        b.property::<String, _>("HwAddress")
            .get(|_, t: &mut T| t.hw_address());
        b.property::<Vec<dbus::Path<'static>>, _>("Ports")
            .get(|_, t: &mut T| t.ports());
    })
}

pub trait OrgFreedesktopNetworkManagerDeviceWired {
    fn hw_address(&self) -> Result<String, dbus::MethodErr>;
    #[deprecated(note = "true")]
    fn perm_hw_address(&self) -> Result<String, dbus::MethodErr>;
    fn speed(&self) -> Result<u32, dbus::MethodErr>;
    fn s390_subchannels(&self) -> Result<Vec<String>, dbus::MethodErr>;
    #[deprecated(note = "true")]
    fn carrier(&self) -> Result<bool, dbus::MethodErr>;
}

pub fn register_org_freedesktop_network_manager_device_wired<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopNetworkManagerDeviceWired + Send + 'static
{
    cr.register("org.freedesktop.NetworkManager.Device.Wired", |b| {
        b.property::<String, _>("HwAddress")
            .get(|_, t: &mut T| t.hw_address());
        b.property::<String, _>("PermHwAddress")
            .get(|_, t: &mut T| t.perm_hw_address())
            .annotate("org.freedesktop.DBus.Deprecated", "true");
        b.property::<u32, _>("Speed")
            .get(|_, t: &mut T| t.speed());
        b.property::<Vec<String>, _>("S390Subchannels")
            .get(|_, t: &mut T| t.s390_subchannels());
        b.property::<bool, _>("Carrier")
            .get(|_, t: &mut T| t.carrier())
            .annotate("org.freedesktop.DBus.Deprecated", "true");
    })
}