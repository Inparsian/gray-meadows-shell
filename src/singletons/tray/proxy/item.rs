// This code was autogenerated with `dbus-codegen-rust --crossroads -d :1.11820 -p /StatusNotifierItem`, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_crossroads as crossroads;

pub type RawPixmap = (i32, i32, Vec<u8>);
pub type RawToolTip = (String, Vec<RawPixmap>, String, String);

pub trait OrgKdeStatusNotifierItem {
    fn context_menu(&mut self, x_: i32, y_: i32) -> Result<(), dbus::MethodErr>;
    fn activate(&mut self, x_: i32, y_: i32) -> Result<(), dbus::MethodErr>;
    fn secondary_activate(&mut self, x_: i32, y_: i32) -> Result<(), dbus::MethodErr>;
    fn scroll(&mut self, delta: i32, orientation: String) -> Result<(), dbus::MethodErr>;
    fn category(&self) -> Result<String, dbus::MethodErr>;
    fn id(&self) -> Result<String, dbus::MethodErr>;
    fn title(&self) -> Result<String, dbus::MethodErr>;
    fn status(&self) -> Result<String, dbus::MethodErr>;
    fn window_id(&self) -> Result<i32, dbus::MethodErr>;
    fn icon_theme_path(&self) -> Result<String, dbus::MethodErr>;
    fn menu(&self) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn item_is_menu(&self) -> Result<bool, dbus::MethodErr>;
    fn icon_name(&self) -> Result<String, dbus::MethodErr>;
    fn icon_pixmap(&self) -> Result<Vec<RawPixmap>, dbus::MethodErr>;
    fn overlay_icon_name(&self) -> Result<String, dbus::MethodErr>;
    fn overlay_icon_pixmap(&self) -> Result<Vec<RawPixmap>, dbus::MethodErr>;
    fn attention_icon_name(&self) -> Result<String, dbus::MethodErr>;
    fn attention_icon_pixmap(&self) -> Result<Vec<RawPixmap>, dbus::MethodErr>;
    fn attention_movie_name(&self) -> Result<String, dbus::MethodErr>;
    fn tool_tip(&self) -> Result<RawToolTip, dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewTitle {
}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewTitle {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewTitle {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewTitle {
        })
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewTitle {
    const NAME: &'static str = "NewTitle";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewIcon {
}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewIcon {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewIcon {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewIcon {
        })
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewIcon {
    const NAME: &'static str = "NewIcon";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewAttentionIcon {
}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewAttentionIcon {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewAttentionIcon {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewAttentionIcon {
        })
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewAttentionIcon {
    const NAME: &'static str = "NewAttentionIcon";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewOverlayIcon {
}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewOverlayIcon {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewOverlayIcon {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewOverlayIcon {
        })
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewOverlayIcon {
    const NAME: &'static str = "NewOverlayIcon";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewMenu {
}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewMenu {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewMenu {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewMenu {
        })
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewMenu {
    const NAME: &'static str = "NewMenu";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewToolTip {
}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewToolTip {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewToolTip {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewToolTip {
        })
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewToolTip {
    const NAME: &'static str = "NewToolTip";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

#[derive(Debug)]
pub struct OrgKdeStatusNotifierItemNewStatus {
    pub status: String,
}

impl arg::AppendAll for OrgKdeStatusNotifierItemNewStatus {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.status, i);
    }
}

impl arg::ReadAll for OrgKdeStatusNotifierItemNewStatus {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgKdeStatusNotifierItemNewStatus {
            status: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgKdeStatusNotifierItemNewStatus {
    const NAME: &'static str = "NewStatus";
    const INTERFACE: &'static str = "org.kde.StatusNotifierItem";
}

pub fn register_org_kde_status_notifier_item<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgKdeStatusNotifierItem + Send + 'static
{
    cr.register("org.kde.StatusNotifierItem", |b| {
        b.signal::<(), _>("NewTitle", ());
        b.signal::<(), _>("NewIcon", ());
        b.signal::<(), _>("NewAttentionIcon", ());
        b.signal::<(), _>("NewOverlayIcon", ());
        b.signal::<(), _>("NewMenu", ());
        b.signal::<(), _>("NewToolTip", ());
        b.signal::<(String,), _>("NewStatus", ("status",));
        b.method("ContextMenu", ("x","y",), (), |_, t: &mut T, (x,y,)| {
            t.context_menu(x,y,)
        });
        b.method("Activate", ("x","y",), (), |_, t: &mut T, (x,y,)| {
            t.activate(x,y,)
        });
        b.method("SecondaryActivate", ("x","y",), (), |_, t: &mut T, (x,y,)| {
            t.secondary_activate(x,y,)
        });
        b.method("Scroll", ("delta","orientation",), (), |_, t: &mut T, (delta,orientation,)| {
            t.scroll(delta,orientation,)
        });
        b.property::<String, _>("Category")
            .get(|_, t: &mut T| t.category());
        b.property::<String, _>("Id")
            .get(|_, t: &mut T| t.id());
        b.property::<String, _>("Title")
            .get(|_, t: &mut T| t.title());
        b.property::<String, _>("Status")
            .get(|_, t: &mut T| t.status());
        b.property::<i32, _>("WindowId")
            .get(|_, t: &mut T| t.window_id());
        b.property::<String, _>("IconThemePath")
            .get(|_, t: &mut T| t.icon_theme_path());
        b.property::<dbus::Path<'static>, _>("Menu")
            .get(|_, t: &mut T| t.menu());
        b.property::<bool, _>("ItemIsMenu")
            .get(|_, t: &mut T| t.item_is_menu());
        b.property::<String, _>("IconName")
            .get(|_, t: &mut T| t.icon_name());
        b.property::<Vec<RawPixmap>, _>("IconPixmap")
            .get(|_, t: &mut T| t.icon_pixmap())
            .annotate("org.qtproject.QtDBus.QtTypeName", "QXdgDBusImageVector");
        b.property::<String, _>("OverlayIconName")
            .get(|_, t: &mut T| t.overlay_icon_name());
        b.property::<Vec<RawPixmap>, _>("OverlayIconPixmap")
            .get(|_, t: &mut T| t.overlay_icon_pixmap())
            .annotate("org.qtproject.QtDBus.QtTypeName", "QXdgDBusImageVector");
        b.property::<String, _>("AttentionIconName")
            .get(|_, t: &mut T| t.attention_icon_name());
        b.property::<Vec<RawPixmap>, _>("AttentionIconPixmap")
            .get(|_, t: &mut T| t.attention_icon_pixmap())
            .annotate("org.qtproject.QtDBus.QtTypeName", "QXdgDBusImageVector");
        b.property::<String, _>("AttentionMovieName")
            .get(|_, t: &mut T| t.attention_movie_name());
        b.property::<(String, Vec<RawPixmap>, String, String,), _>("ToolTip")
            .get(|_, t: &mut T| t.tool_tip())
            .annotate("org.qtproject.QtDBus.QtTypeName", "QXdgDBusToolTipStruct");
    })
}

pub trait OrgFreedesktopDBusProperties {
    fn get(&mut self, interface_name: String, property_name: String) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::MethodErr>;
    fn set(&mut self, interface_name: String, property_name: String, value: arg::Variant<Box<dyn arg::RefArg + 'static>>) -> Result<(), dbus::MethodErr>;
    fn get_all(&mut self, interface_name: String) -> Result<arg::PropMap, dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface_name: String,
    pub changed_properties: arg::PropMap,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface_name, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface_name: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

pub fn register_org_freedesktop_dbus_properties<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusProperties + Send + 'static
{
    cr.register("org.freedesktop.DBus.Properties", |b| {
        b.signal::<(String,arg::PropMap,Vec<String>,), _>("PropertiesChanged", ("interface_name","changed_properties","invalidated_properties",))
            .annotate("org.qtproject.QtDBus.QtTypeName.Out1", "QVariantMap");
        b.method("Get", ("interface_name","property_name",), ("value",), |_, t: &mut T, (interface_name,property_name,)| {
            t.get(interface_name,property_name,)
                .map(|x| (x,))
        });
        b.method("Set", ("interface_name","property_name","value",), (), |_, t: &mut T, (interface_name,property_name,value,)| {
            t.set(interface_name,property_name,value,)
        });
        b.method("GetAll", ("interface_name",), ("values",), |_, t: &mut T, (interface_name,)| {
            t.get_all(interface_name,)
                .map(|x| (x,))
        })
            .annotate("org.qtproject.QtDBus.QtTypeName.Out0", "QVariantMap");
    })
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&mut self) -> Result<String, dbus::MethodErr>;
}

pub fn register_org_freedesktop_dbus_introspectable<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusIntrospectable + Send + 'static
{
    cr.register("org.freedesktop.DBus.Introspectable", |b| {
        b.method("Introspect", (), ("xml_data",), |_, t: &mut T, ()| {
            t.introspect()
                .map(|x| (x,))
        });
    })
}

pub trait OrgFreedesktopDBusPeer {
    fn ping(&mut self) -> Result<(), dbus::MethodErr>;
    fn get_machine_id(&mut self) -> Result<String, dbus::MethodErr>;
}

pub fn register_org_freedesktop_dbus_peer<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusPeer + Send + 'static
{
    cr.register("org.freedesktop.DBus.Peer", |b| {
        b.method("Ping", (), (), |_, t: &mut T, ()| {
            t.ping()
        });
        b.method("GetMachineId", (), ("machine_uuid",), |_, t: &mut T, ()| {
            t.get_machine_id()
                .map(|x| (x,))
        });
    })
}