// This code was autogenerated with `dbus-codegen-rust --crossroads -d :1.1844 -p /MenuBar`, see https://github.com/diwic/dbus-rs
#![allow(non_snake_case)]
#![allow(dead_code)]
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_crossroads as crossroads;

pub type RawLayout = (u32, RawMenuItem);
pub type RawMenuItem = (i32, arg::PropMap, Vec<arg::Variant<Box<dyn arg::RefArg + 'static>>>,);
pub type RawEvent = (i32, String, arg::Variant<Box<dyn arg::RefArg + 'static>>, u32,);

pub trait ComCanonicalDbusmenu {
    fn get_layout(&mut self, parent_id: i32, recursion_depth: i32, property_names: Vec<String>) -> Result<RawLayout, dbus::MethodErr>;
    fn get_group_properties(&mut self, ids: Vec<i32>, property_names: Vec<String>) -> Result<Vec<(i32, arg::PropMap,)>, dbus::MethodErr>;
    fn get_property(&mut self, id: i32, name: String) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::MethodErr>;
    fn event(&mut self, id: i32, event_id: String, data: arg::Variant<Box<dyn arg::RefArg + 'static>>, timestamp: u32) -> Result<(), dbus::MethodErr>;
    fn event_group(&mut self, events: Vec<RawEvent>) -> Result<Vec<i32>, dbus::MethodErr>;
    fn about_to_show(&mut self, id: i32) -> Result<bool, dbus::MethodErr>;
    fn about_to_show_group(&mut self, ids: Vec<i32>) -> Result<(Vec<i32>, Vec<i32>), dbus::MethodErr>;
    fn version(&self) -> Result<u32, dbus::MethodErr>;
    fn text_direction(&self) -> Result<String, dbus::MethodErr>;
    fn status(&self) -> Result<String, dbus::MethodErr>;
    fn icon_theme_path(&self) -> Result<Vec<String>, dbus::MethodErr>;
}

#[derive(Debug)]
pub struct ComCanonicalDbusmenuItemsPropertiesUpdated {
    pub updated_props: Vec<(i32, arg::PropMap,)>,
    pub removed_props: Vec<(i32, Vec<String>,)>,
}

impl arg::AppendAll for ComCanonicalDbusmenuItemsPropertiesUpdated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.updated_props, i);
        arg::RefArg::append(&self.removed_props, i);
    }
}

impl arg::ReadAll for ComCanonicalDbusmenuItemsPropertiesUpdated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ComCanonicalDbusmenuItemsPropertiesUpdated {
            updated_props: i.read()?,
            removed_props: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ComCanonicalDbusmenuItemsPropertiesUpdated {
    const NAME: &'static str = "ItemsPropertiesUpdated";
    const INTERFACE: &'static str = "com.canonical.dbusmenu";
}

#[derive(Debug)]
pub struct ComCanonicalDbusmenuLayoutUpdated {
    pub revision: u32,
    pub parent: i32,
}

impl arg::AppendAll for ComCanonicalDbusmenuLayoutUpdated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.revision, i);
        arg::RefArg::append(&self.parent, i);
    }
}

impl arg::ReadAll for ComCanonicalDbusmenuLayoutUpdated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ComCanonicalDbusmenuLayoutUpdated {
            revision: i.read()?,
            parent: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ComCanonicalDbusmenuLayoutUpdated {
    const NAME: &'static str = "LayoutUpdated";
    const INTERFACE: &'static str = "com.canonical.dbusmenu";
}

#[derive(Debug)]
pub struct ComCanonicalDbusmenuItemActivationRequested {
    pub id: i32,
    pub timestamp: u32,
}

impl arg::AppendAll for ComCanonicalDbusmenuItemActivationRequested {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.id, i);
        arg::RefArg::append(&self.timestamp, i);
    }
}

impl arg::ReadAll for ComCanonicalDbusmenuItemActivationRequested {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ComCanonicalDbusmenuItemActivationRequested {
            id: i.read()?,
            timestamp: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ComCanonicalDbusmenuItemActivationRequested {
    const NAME: &'static str = "ItemActivationRequested";
    const INTERFACE: &'static str = "com.canonical.dbusmenu";
}

pub fn register_com_canonical_dbusmenu<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: ComCanonicalDbusmenu + Send + 'static
{
    cr.register("com.canonical.dbusmenu", |b| {
        b.signal::<(Vec<(i32, arg::PropMap,)>,Vec<(i32, Vec<String>,)>,), _>("ItemsPropertiesUpdated", ("updatedProps","removedProps",))
            .annotate("org.qtproject.QtDBus.QtTypeName.In1", "QDBusMenuItemKeysList")
            .annotate("org.qtproject.QtDBus.QtTypeName.In0", "QDBusMenuItemList");
        b.signal::<(u32,i32,), _>("LayoutUpdated", ("revision","parent",));
        b.signal::<(i32,u32,), _>("ItemActivationRequested", ("id","timestamp",));
        b.method("GetLayout", ("parentId","recursionDepth","propertyNames",), ("revision","layout",), |_, t: &mut T, (parentId,recursionDepth,propertyNames,)| {
            t.get_layout(parentId,recursionDepth,propertyNames,)
        })
            .annotate("org.qtproject.QtDBus.QtTypeName.Out1", "QDBusMenuLayoutItem");
        b.method("GetGroupProperties", ("ids","propertyNames",), ("properties",), |_, t: &mut T, (ids,propertyNames,)| {
            t.get_group_properties(ids,propertyNames,)
                .map(|x| (x,))
        })
            .annotate("org.qtproject.QtDBus.QtTypeName.In0", "QList<int>")
            .annotate("org.qtproject.QtDBus.QtTypeName.Out0", "QDBusMenuItemList");
        b.method("GetProperty", ("id","name",), ("value",), |_, t: &mut T, (id,name,)| {
            t.get_property(id,name,)
                .map(|x| (x,))
        });
        b.method("Event", ("id","eventId","data","timestamp",), (), |_, t: &mut T, (id,eventId,data,timestamp,)| {
            t.event(id,eventId,data,timestamp,)
        });
        b.method("EventGroup", ("events",), ("idErrors",), |_, t: &mut T, (events,)| {
            t.event_group(events,)
                .map(|x| (x,))
        })
            .annotate("org.qtproject.QtDBus.QtTypeName.In0", "QList<QDBusMenuEvent>")
            .annotate("org.qtproject.QtDBus.QtTypeName.Out0", "QList<int>");
        b.method("AboutToShow", ("id",), ("needUpdate",), |_, t: &mut T, (id,)| {
            t.about_to_show(id,)
                .map(|x| (x,))
        });
        b.method("AboutToShowGroup", ("ids",), ("updatesNeeded","idErrors",), |_, t: &mut T, (ids,)| {
            t.about_to_show_group(ids,)
        })
            .annotate("org.qtproject.QtDBus.QtTypeName.Out0", "QList<int>")
            .annotate("org.qtproject.QtDBus.QtTypeName.In0", "QList<int>")
            .annotate("org.qtproject.QtDBus.QtTypeName.Out1", "QList<int>");
        b.property::<u32, _>("Version")
            .get(|_, t: &mut T| t.version());
        b.property::<String, _>("TextDirection")
            .get(|_, t: &mut T| t.text_direction());
        b.property::<String, _>("Status")
            .get(|_, t: &mut T| t.status());
        b.property::<Vec<String>, _>("IconThemePath")
            .get(|_, t: &mut T| t.icon_theme_path());
    })
}

pub trait OrgFreedesktopDBusProperties {
    fn get(&mut self, interface_name: String, property_name: String) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::MethodErr>;
    fn set(&mut self, interface_name: String, property_name: String, value: arg::Variant<Box<dyn arg::RefArg + 'static>>) -> Result<(), dbus::MethodErr>;
    fn get_all(&mut self, interface_name: String) -> Result<arg::PropMap, dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface_name: String,
    pub changed_properties: arg::PropMap,
    pub invalidated_properties: Vec<String>,
}

impl arg::AppendAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface_name, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
}

impl arg::ReadAll for OrgFreedesktopDBusPropertiesPropertiesChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopDBusPropertiesPropertiesChanged {
            interface_name: i.read()?,
            changed_properties: i.read()?,
            invalidated_properties: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
}

pub fn register_org_freedesktop_dbus_properties<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusProperties + Send + 'static
{
    cr.register("org.freedesktop.DBus.Properties", |b| {
        b.signal::<(String,arg::PropMap,Vec<String>,), _>("PropertiesChanged", ("interface_name","changed_properties","invalidated_properties",))
            .annotate("org.qtproject.QtDBus.QtTypeName.Out1", "QVariantMap");
        b.method("Get", ("interface_name","property_name",), ("value",), |_, t: &mut T, (interface_name,property_name,)| {
            t.get(interface_name,property_name,)
                .map(|x| (x,))
        });
        b.method("Set", ("interface_name","property_name","value",), (), |_, t: &mut T, (interface_name,property_name,value,)| {
            t.set(interface_name,property_name,value,)
        });
        b.method("GetAll", ("interface_name",), ("values",), |_, t: &mut T, (interface_name,)| {
            t.get_all(interface_name,)
                .map(|x| (x,))
        })
            .annotate("org.qtproject.QtDBus.QtTypeName.Out0", "QVariantMap");
    })
}

pub trait OrgFreedesktopDBusIntrospectable {
    fn introspect(&mut self) -> Result<String, dbus::MethodErr>;
}

pub fn register_org_freedesktop_dbus_introspectable<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusIntrospectable + Send + 'static
{
    cr.register("org.freedesktop.DBus.Introspectable", |b| {
        b.method("Introspect", (), ("xml_data",), |_, t: &mut T, ()| {
            t.introspect()
                .map(|x| (x,))
        });
    })
}

pub trait OrgFreedesktopDBusPeer {
    fn ping(&mut self) -> Result<(), dbus::MethodErr>;
    fn get_machine_id(&mut self) -> Result<String, dbus::MethodErr>;
}

pub fn register_org_freedesktop_dbus_peer<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: OrgFreedesktopDBusPeer + Send + 'static
{
    cr.register("org.freedesktop.DBus.Peer", |b| {
        b.method("Ping", (), (), |_, t: &mut T, ()| {
            t.ping()
        });
        b.method("GetMachineId", (), ("machine_uuid",), |_, t: &mut T, ()| {
            t.get_machine_id()
                .map(|x| (x,))
        });
    })
}